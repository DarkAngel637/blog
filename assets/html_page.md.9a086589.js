import{_ as t,o,c as e,Q as l}from"./chunks/framework.7204edfa.js";const m=JSON.parse('{"title":"html","description":"","frontmatter":{},"headers":[],"relativePath":"html/page.md","filePath":"html/page.md"}'),i={name:"html/page.md"},a=l('<h1 id="html" tabindex="-1">html <a class="header-anchor" href="#html" aria-label="Permalink to &quot;html&quot;">​</a></h1><h3 id="重绘-repaint-不涉及到元素的位置和大小等计算" tabindex="-1">重绘（repaint） --- 不涉及到元素的位置和大小等计算 <a class="header-anchor" href="#重绘-repaint-不涉及到元素的位置和大小等计算" aria-label="Permalink to &quot;重绘（repaint） --- 不涉及到元素的位置和大小等计算&quot;">​</a></h3><p>重绘，就是重新绘制。发生了<strong>不改变元素物理信息的情况</strong>下只会进行重绘。比如将元素的背景色修改了，就要将元素的盒子做一个重新渲染。 <strong>重绘不会改变页面的布局</strong>，只是对局部区域重新渲染，一般来说不会导致严重的性能问题。</p><ul><li>样式更改：当修改了元素的样式属性，例如颜色、背景、边框、文本样式等，浏览器需要根据新的样式重新计算并绘制元素。</li><li>页面初始化：当页面首次加载时，浏览器需要绘制整个页面。</li><li>修改元素的 box-shadow、text-shadow、outline 等属性</li><li>添加、移除、修改元素的 class；</li><li>使用 JavaScript 直接修改样式。</li><li>用户交互事件：例如鼠标悬停、点击按钮、滚动页面等，这些交互事件可能导致元素样式变化，从而触发重绘。</li><li>动画效果：使用 CSS 或 JavaScript 实现的动画效果（如过渡、动画）通常会引起频繁的重绘操作(如: 使用 CSS3 transform 和 opacity 等属性；)。</li><li>浏览器窗口大小改变：当用户调整浏览器窗口大小时，页面中的元素需要根据新的视口尺寸进行重排和重绘。</li><li>媒体查询变化：当使用媒体查询来响应不同的设备或屏幕尺寸时，浏览器会根据媒体查询的结果进行重绘。</li><li>JavaScript 操作：某些 JavaScript 操作可能导致页面布局或样式的改变，从而引发重绘。</li><li>添加、移除、修改元素的 class</li></ul><h2 id="重排-reflow-涉及到大量的计算和页面重排" tabindex="-1">重排（reflow）--- 涉及到大量的计算和页面重排 <a class="header-anchor" href="#重排-reflow-涉及到大量的计算和页面重排" aria-label="Permalink to &quot;重排（reflow）--- 涉及到大量的计算和页面重排&quot;">​</a></h2><h4>关键词: <code>元素及页面尺寸</code>,<code>显隐</code>,<code>定位</code>,<code>盒模型</code>,<code>getComputedStyle</code></h4><p>重排，就是重新排布。 当元素的<strong>物理信息发生变化时</strong>，其后的元素就会改变位置，此时就要重新进行布局，计算元素的物理信息。(<strong>元素及页面尺寸,显隐,定位,盒模型,getComputedStyle 的调用</strong>) 比如修改元素的高度，将元素设置为 display: none; 等操作会导致重排。</p><ul><li><strong>页面初始化</strong>：当页面首次加载时，浏览器需要进行初始的重排操作来确定元素的布局。</li><li><strong>样式更改</strong>：当修改了元素的样式属性，例如<strong>宽度、高度、定位</strong>等，浏览器需要重新计算元素的布局信息。</li><li><strong>添加或删除元素</strong>：当添加或删除元素时，整个页面的布局可能会受到影响，从而触发重排(DOM 结构的变化)</li><li><strong>文字内容变化</strong>：如果文字内容的长度发生变化，例如动态插入、删除或修改文字，浏览器会重新计算文本所占的空间，进而引起重排。</li><li><strong>页面尺寸改变</strong>：当用户调整浏览器窗口大小或设备旋转时，浏览器会重新计算页面的布局。</li><li><strong>盒模型属性变化</strong>：改变盒模型属性（如边距、边框、填充等）可能会导致元素的尺寸和位置发生变化，从而引发重排。</li><li><strong>获取元素的几何属性</strong>，比如调用 getComputedStyle() 方法获取元素的尺寸、位置等信息</li></ul><p><strong>回流一定会引起重绘,重绘不一定引起回流</strong></p><h3 id="如何避免重绘重排" tabindex="-1">如何避免重绘重排 <a class="header-anchor" href="#如何避免重绘重排" aria-label="Permalink to &quot;如何避免重绘重排&quot;">​</a></h3><h4>关键词: <code>尽量少操作dom</code>,<code>或者变化频繁的放到新层</code>,<code>尽量一次添加完要添加的元素</code></h4><ul><li><strong>减少 DOM 操作</strong>。像是 Vue 和 React 通过虚拟 DOM 找出不同，以减少更新 DOM 的操作；</li><li><strong>尽量将要添加的元素都生成好，再一次性添加到文档流中</strong>，而不是一个个加上去；</li><li><strong>缓存好要用的布局信息</strong>。对于同时调用多次修改 DOM 的 API 操作，浏览器是有优化的，会将这些操作缓存起来，然后一次性更新。但如果在这过程中访问了布局相关信息（比如 scrollHeight、getBoundingClientRect）时，就会强制进行重渲染去获取最新布局数据；</li><li><strong>将经常变化的元素放到新的层</strong>。通过 transform 或绝对定位产生新的渲染层，防止影响文档流；</li><li>避免使用 getComputedStyle() 获取元素信息 因为 getComputedStyle() 方法会强制浏览器进行回流操作，从而影响页面的性能。如果需要获取元素的信息，可以在修改样式之前先保存到变量中，避免多次触发回流。</li><li>使用 position:absolute 或者 position:fixed 属性 使用 position:absolute 或者 position:fixed 属性可以将元素从文档流中脱离出来，从而避免影响其他元素的位置和大小。虽然这也会引起回流，但是相对于修改文档流中的元素来说，开销较小，对页面的性能影响较小。</li><li>尽量一次性修改样式 可以使用 cssText 属性、添加 class 等方式，一次性修改元素的样式，避免多次修改引起页面的回流。比如，可以将需要修改的样式保存在一个对象中，然后一次性设置给元素，避免多次触发回流。 平时我们<strong>应该尽量避免频繁一次性修改大量 DOM</strong>。好在我们平常使用类似 Vue 和 React 的框架，能够通过对比新旧虚拟 DOM 减少对真实 DOM 的操作，将 GPU 密集转移到了 CPU 密集，也算各有利弊吧。</li></ul>',12),r=[a];function s(n,c,d,g,h,p){return o(),e("div",null,r)}const _=t(i,[["render",s]]);export{m as __pageData,_ as default};
